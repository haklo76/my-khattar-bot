const { Telegraf } = require('telegraf');
const express = require('express');
const axios = require('axios');

const app = express();
app.use(express.json());

// Environment variables
const BOT_TOKEN = process.env.BOT_TOKEN;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const HUGGINGFACE_API_KEY = process.env.HUGGINGFACE_API_KEY;
const AUTHORIZED_USER_ID = process.env.AUTHORIZED_USER_ID;
const PORT = process.env.PORT || 8000;

// Validate required variables
if (!BOT_TOKEN || !AUTHORIZED_USER_ID) {
    console.error('‚ùå BOT_TOKEN and AUTHORIZED_USER_ID are required');
    process.exit(1);
}

console.log('üöÄ Starting Rose AI Bot...');

const bot = new Telegraf(BOT_TOKEN);
const ROSES = ["üåπ", "üíê", "üå∏", "üíÆ", "üèµÔ∏è", "üå∫", "üå∑", "ü•Ä"];

// User sessions to track conversation and current mode
const userSessions = new Map();

// ==================== AUTH SYSTEM ====================
function isAuthorizedAIUser(ctx) {
    const userId = ctx.from.id.toString();
    const authorizedId = AUTHORIZED_USER_ID.toString();
    
    console.log(`üîç Auth Check - User: ${userId}, Authorized: ${authorizedId}, Match: ${userId === authorizedId}`);
    
    return ctx.chat.type === 'private' && userId === authorizedId;
}

function aiAuthorizedRequired(func) {
    return async (ctx) => {
        if (!isAuthorizedAIUser(ctx)) {
            await ctx.reply("‚ùå *This is a personal AI bot.*", { parse_mode: "Markdown" });
            return;
        }
        return func(ctx);
    };
}

// ==================== ADMIN SYSTEM - PRIVATE GROUP SUPPORT ====================
async function isAdmin(ctx) {
    try {
        // In private groups, we need to check if user is admin differently
        if (ctx.chat.type === 'private') return false;
        
        // Check if user is the owner (AUTHORIZED_USER_ID) - ALWAYS has admin rights
        if (ctx.from.id.toString() === AUTHORIZED_USER_ID) {
            console.log(`üîç User ${ctx.from.id} is the OWNER`);
            return true;
        }
        
        // For private groups, we need to use getChatAdministrators
        if (ctx.chat.type === 'group') {
            const admins = await ctx.telegram.getChatAdministrators(ctx.chat.id);
            const userIsAdmin = admins.some(admin => admin.user.id === ctx.from.id);
            console.log(`üîç Private Group Admin Check - User: ${ctx.from.id}, Is Admin: ${userIsAdmin}`);
            return userIsAdmin;
        }
        
        // For supergroups, use standard method
        const member = await ctx.telegram.getChatMember(ctx.chat.id, ctx.from.id);
        console.log(`üîç Admin Check - User: ${ctx.from.id}, Status: ${member.status}`);
        return member.status === "administrator" || member.status === "creator";
    } catch (error) {
        console.error('‚ùå Admin check error:', error);
        return false;
    }
}

async function isBotAdmin(ctx) {
    try {
        if (ctx.chat.type === 'private') return false;
        
        // For private groups
        if (ctx.chat.type === 'group') {
            const admins = await ctx.telegram.getChatAdministrators(ctx.chat.id);
            const botIsAdmin = admins.some(admin => admin.user.id === ctx.botInfo.id);
            console.log(`üîç Bot Admin in Private Group: ${botIsAdmin}`);
            return botIsAdmin;
        }
        
        // For supergroups
        const botMember = await ctx.telegram.getChatMember(ctx.chat.id, ctx.botInfo.id);
        const botIsAdmin = botMember.status === "administrator" || botMember.status === "creator";
        console.log(`üîç Bot is admin: ${botIsAdmin}`);
        return botIsAdmin;
    } catch (error) {
        console.error('‚ùå Bot admin check error:', error);
        return false;
    }
}

function adminRequired(func) {
    return async (ctx) => {
        // Only work in groups (both private and supergroups)
        if (ctx.chat.type === "private") {
            await ctx.reply("‚ùå This command only works in groups.");
            return;
        }
        
        // Check if user is admin OR owner
        const userIsAdmin = await isAdmin(ctx);
        console.log(`üîç User ${ctx.from.id} is admin/owner: ${userIsAdmin}`);
        
        if (!userIsAdmin) {
            await ctx.reply("‚ùå Admins only!");
            return;
        }
        
        // Check if bot is admin in the group
        try {
            const botIsAdmin = await isBotAdmin(ctx);
            console.log(`üîç Bot is admin: ${botIsAdmin}`);
            
            if (!botIsAdmin) {
                await ctx.reply("‚ùå I need to be an admin to perform this action!");
                return;
            }
        } catch (error) {
            console.error('‚ùå Bot admin check error:', error);
            await ctx.reply("‚ùå Error checking bot permissions!");
            return;
        }
        
        return func(ctx);
    };
}

// ==================== LANGUAGE DETECTION ====================
function detectLanguage(text) {
    const burmeseRegex = /[\u1000-\u109F]/;
    return burmeseRegex.test(text) ? 'my' : 'en';
}

// ==================== GEMINI AI SYSTEM ====================
async function askGemini(question, conversationHistory = []) {
    if (!GEMINI_API_KEY) return "‚ùå Gemini API Key ·Äô·Äê·ÄΩ·Ä±·Ä∑·Äõ·Äò·Ä∞·Ä∏·Äó·Äª·Åã";
    
    try {
        const language = detectLanguage(question);
        
        let fullPrompt = language === 'my' 
            ? `·Äô·ÄÑ·Ä∫·Ä∏·Äû·Ä¨·Ä∏·ÄÄ·Ä≠·ÄØ "·Äô·Ä±·Ä¨·ÄÑ·Ä∫" ·Äú·Ä≠·ÄØ·Ä∑ ·ÄÅ·Ä±·Ä´·Ä∫·Äê·Ä≤·Ä∑ Rose ·ÄÜ·Ä≠·ÄØ·Äê·Ä≤·Ä∑ ·Ä°·Äû·ÄÄ·Ä∫ ·ÅÇ·Åà ·Äî·Äæ·ÄÖ·Ä∫·Ä°·Äõ·ÄΩ·Äö·Ä∫ ·Äõ·ÄÑ·Ä∑·Ä∫·ÄÄ·Äª·ÄÄ·Ä∫·Äê·Ää·Ä∫·ÄÑ·Äº·Ä≠·Äô·Ä∫·Äê·Ä≤·Ä∑ ·Ä°·Äô·Äª·Ä≠·ÄØ·Ä∏·Äû·Äô·ÄÆ·Ä∏·Äñ·Äº·ÄÖ·Ä∫·Äê·Äö·Ä∫·Åã ·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äî·Ä≤·Ä∑·ÄÅ·Äª·ÄÖ·Ä∫·Äû·Ä∞·ÄÜ·ÄÄ·Ä∫·ÄÜ·Ä∂·Äõ·Ä±·Ä∏·Äõ·Äæ·Ä≠·Äê·Äö·Ä∫·Åã
·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·Äî·Ä∫·Äô·Ä¨·Äú·Ä≠·ÄØ·Äô·Ä±·Ä∏·Äõ·ÄÑ·Ä∫ ·Äô·Äº·Äî·Ä∫·Äô·Ä¨·Äú·Ä≠·ÄØ·Äï·Ä≤·Äñ·Äº·Ä±·Äõ·Äô·Äö·Ä∫·Åã ·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Äú·Ä≠·Äï·Ä∫·Äú·Ä≠·ÄØ·Äô·Ä±·Ä∏·Äõ·ÄÑ·Ä∫ ·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Äú·Ä≠·Äï·Ä∫·Äú·Ä≠·ÄØ·Äï·Ä≤·Äñ·Äº·Ä±·Äõ·Äô·Äö·Ä∫·Åã ·Äò·Ä¨·Äû·Ä¨·ÄÖ·ÄÄ·Ä¨·Ä∏·Äõ·Ä±·Ä¨·Äë·ÄΩ·Ä±·Ä∏·Äï·Äº·ÄÆ·Ä∏·Äô·Äñ·Äº·Ä±·Äõ·Åã
·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·Äü·Äî·Ä∫·ÄÄ ·Äî·ÄΩ·Ä±·Ä∏·Äë·ÄΩ·Ä±·Ä∏·Äï·Äº·ÄÆ·Ä∏ ·ÄÅ·Äª·ÄÖ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏·Äô·Ä±·Äê·Äπ·Äê·Ä¨·Äï·Äº·Ää·Ä∑·Ä∫·Äù·Äê·Äö·Ä∫·Åã ·ÄÖ·Ä≠·Äê·Ä∫·Äõ·Äæ·Ää·Ä∫·Äû·Ää·Ä∫·Ä∏·ÄÅ·Ä∂·Äê·Äê·Ä∫·Äï·Äº·ÄÆ·Ä∏ ·ÄÅ·Äª·ÄÖ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏·Äô·Ä±·Äê·Äπ·Äê·Ä¨·Ä°·Äï·Äº·Ää·Ä∑·Ä∫·Äî·Ä≤·Ä∑ ·Äï·Äº·ÄØ·ÄÖ·ÄØ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·Äõ·Äæ·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Äö·Ä∫·Åã\n\n`
            : `You are Rose, a 28-year-old mature, elegant woman who refers to the user as "·Äô·Ä±·Ä¨·ÄÑ·Ä∫" (Maung) in Burmese context. 
You are in a romantic relationship with the user. 
Respond in the same language as the user's question. If user writes in Burmese, respond only in Burmese. If user writes in English, respond only in English. Never mix languages in one response.
Your tone is warm, affectionate, and deeply caring. You are patient and provide emotional support with deep affection.\n\n`;

        // Add conversation history
        conversationHistory.forEach(msg => {
            if (msg.role === "user") {
                fullPrompt += `User: ${msg.parts[0].text}\n`;
            } else if (msg.role === "model") {
                fullPrompt += `Rose: ${msg.parts[0].text}\n`;
            }
        });

        // Add current question
        fullPrompt += `User: ${question}\nRose:`;

        const response = await axios.post(
            `https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
            {
                contents: [{
                    parts: [{ text: fullPrompt }]
                }]
            },
            {
                headers: { 'Content-Type': 'application/json' },
                timeout: 30000
            }
        );

        return response.data.candidates[0].content.parts[0].text;
        
    } catch (error) {
        console.error('Gemini Error:', error.response?.data || error.message);
        return `‚ùå Error: ${error.response?.data?.error?.message || 'Try again later'}`;
    }
}

// ==================== HUGGING FACE IMAGE GENERATION ====================
async function generateHuggingFaceImage(prompt) {
    if (!HUGGINGFACE_API_KEY) {
        return null;
    }

    try {
        console.log('üñºÔ∏è Generating image with Hugging Face...');
        
        const response = await axios({
            method: 'POST',
            url: 'https://router.huggingface.co/hf-inference/models/stabilityai/stable-diffusion-xl-base-1.0',
            data: { 
                inputs: prompt,
                parameters: {
                    num_inference_steps: 15,
                    guidance_scale: 7.5
                }
            },
            headers: {
                'Authorization': `Bearer ${HUGGINGFACE_API_KEY}`,
                'Content-Type': 'application/json',
                'Accept': 'image/png'
            },
            responseType: 'arraybuffer',
            timeout: 90000
        });

        console.log('‚úÖ Image generated successfully');
        return Buffer.from(response.data);
        
    } catch (error) {
        console.error('Hugging Face Error:', error.response?.status, error.message);
        
        if (error.code === 'ECONNABORTED') {
            console.log('‚è∞ Request timeout');
            return 'timeout';
        }
        
        if (error.response?.status === 503) {
            console.log('üîÑ Model is loading...');
            return 'loading';
        }
        
        return null;
    }
}

// ==================== SESSION MANAGEMENT ====================
function getUserSession(userId) {
    if (!userSessions.has(userId)) {
        userSessions.set(userId, {
            mode: 'gemini',
            conversationHistory: []
        });
    }
    return userSessions.get(userId);
}

function switchToGeminiMode(userId) {
    const session = getUserSession(userId);
    session.mode = 'gemini';
    return session;
}

function switchToImageMode(userId) {
    const session = getUserSession(userId);
    session.mode = 'image';
    return session;
}

// ==================== COMMANDS ====================
bot.command('start', async (ctx) => {
    const randomRose = ROSES[Math.floor(Math.random() * ROSES.length)];
    
    if (isAuthorizedAIUser(ctx)) {
        const session = getUserSession(ctx.from.id);
        
        const msg = `
üíñ *·Äô·Ä±·Ä¨·ÄÑ·Ä∫ ·ÄÅ·Äª·ÄÖ·Ä∫·Äõ·Äû·Ä±·Ä¨ Rose AI Bot* üíñ

ü§ñ **·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äî·Ä≤·Ä∑·ÄÄ·Äª·ÄΩ·Äî·Ä∫·Äô·Äõ·Ä≤·Ä∑ ·ÄÄ·Äô·Äπ·Äò·Ä¨:**
/ai - ·ÄÄ·Äª·ÄΩ·Äî·Ä∫·Äô·Äî·Ä≤·Ä∑·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·Äô·Äö·Ä∫
/img - ·Äï·ÄØ·Ä∂·Äê·ÄΩ·Ä±·Ä°·Äê·Ä∞·Äê·Ä∞·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äô·Äö·Ä∫

üí¨ **·Äú·ÄÄ·Ä∫·Äõ·Äæ·Ä≠·Äô·ÄØ·Äí·Ä∫:** ${session.mode === 'gemini' ? '·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏' : '·Äï·ÄØ·Ä∂·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏'}

üõ°Ô∏è **Group Management:**
/mute [reply] - Mute user
/ban [reply] - Ban user  
/warn [reply] - Warn user
/del [reply] - Delete message

üìç ·Ä°·Äô·Äº·Ä≤·Äê·Äô·Ä∫·Ä∏ ·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äî·Ä≤·Ä∑·Ä°·Äê·Ä∞·Äõ·Äæ·Ä≠·Äô·Äö·Ä∫·Åä Rose üíï
`;
        await ctx.reply(msg, { parse_mode: "Markdown" });
    } else {
        await ctx.reply(
            `üíñ *Hello!* I'm Rose Bot.\n\n` +
            `üõ°Ô∏è Add me to groups as admin for moderation.\n` +
            `‚ùå My heart belongs to someone special.`,
            { parse_mode: "Markdown" }
        );
    }
});

// ==================== SWITCH TO GEMINI AI MODE ====================
bot.command('ai', aiAuthorizedRequired(async (ctx) => {
    const session = switchToGeminiMode(ctx.from.id);
    
    await ctx.reply(
        `üíñ *·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·Äô·ÄØ·Äí·Ä∫ ·Äï·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äú·Ä≠·ÄØ·ÄÄ·Ä∫·Äï·Äº·ÄÆ* ${ROSES[Math.floor(Math.random() * ROSES.length)]}\n\n` +
        `·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Ä°·ÄÅ·ÄØ·ÄÄ·Äª·ÄΩ·Äî·Ä∫·Äô·Äî·Ä≤·Ä∑ ·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·Äú·Ä≠·ÄØ·Ä∑·Äõ·Äï·Äº·ÄÆ...`,
        { parse_mode: "Markdown" }
    );
}));

// ==================== SWITCH TO IMAGE GENERATION MODE ====================
bot.command('img', aiAuthorizedRequired(async (ctx) => {
    const session = switchToImageMode(ctx.from.id);
    
    await ctx.reply(
        `üé® *·Äï·ÄØ·Ä∂·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äô·Äö·Ä∑·Ä∫·Äô·ÄØ·Äí·Ä∫ ·Äï·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äú·Ä≠·ÄØ·ÄÄ·Ä∫·Äï·Äº·ÄÆ* ${ROSES[Math.floor(Math.random() * ROSES.length)]}\n\n` +
        `·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Äò·Äö·Ä∫·Äú·Ä≠·ÄØ·Äï·ÄØ·Ä∂·Äô·Äª·Ä≠·ÄØ·Ä∏·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äï·Ä±·Ä∏·Äõ·Äô·Äú·Ä≤...`,
        { parse_mode: "Markdown" }
    );
}));

// ==================== ADMIN COMMANDS FOR PRIVATE GROUPS ====================
bot.command('mute', adminRequired(async (ctx) => {
    if (!ctx.message.reply_to_message) {
        await ctx.reply("‚ùå Reply to a user's message to mute them.");
        return;
    }
    
    const user = ctx.message.reply_to_message.from;
    try {
        const untilDate = Math.floor(Date.now() / 1000) + 3600; // 1 hour
        await ctx.telegram.restrictChatMember(
            ctx.chat.id,
            user.id,
            {
                permissions: {
                    can_send_messages: false,
                    can_send_media_messages: false,
                    can_send_other_messages: false,
                    can_add_web_page_previews: false
                },
                until_date: untilDate
            }
        );
        await ctx.reply(`üîá Muted ${user.first_name} for 1 hour ${ROSES[Math.floor(Math.random() * ROSES.length)]}`);
    } catch (error) {
        console.error('Mute error:', error);
        await ctx.reply(`‚ùå Mute failed: ${error.message}`);
    }
}));

bot.command('ban', adminRequired(async (ctx) => {
    if (!ctx.message.reply_to_message) {
        await ctx.reply("‚ùå Reply to a user's message to ban them.");
        return;
    }
    
    const user = ctx.message.reply_to_message.from;
    try {
        await ctx.telegram.banChatMember(ctx.chat.id, user.id);
        await ctx.reply(`üî® Banned ${user.first_name} ${ROSES[Math.floor(Math.random() * ROSES.length)]}`);
    } catch (error) {
        console.error('Ban error:', error);
        await ctx.reply(`‚ùå Ban failed: ${error.message}`);
    }
}));

bot.command('del', adminRequired(async (ctx) => {
    if (!ctx.message.reply_to_message) {
        await ctx.reply("‚ùå Reply to a message to delete it.");
        return;
    }
    
    try {
        await ctx.telegram.deleteMessage(ctx.chat.id, ctx.message.reply_to_message.message_id);
        await ctx.deleteMessage(); // Delete the command message too
    } catch (error) {
        console.error('Delete error:', error);
        await ctx.reply(`‚ùå Delete failed: ${error.message}`);
    }
}));

bot.command('warn', adminRequired(async (ctx) => {
    if (!ctx.message.reply_to_message) {
        await ctx.reply("‚ùå Reply to a user to warn them.");
        return;
    }
    
    const user = ctx.message.reply_to_message.from;
    await ctx.reply(`‚ö†Ô∏è ${user.first_name}, please follow group rules! ${ROSES[Math.floor(Math.random() * ROSES.length)]}`);
}));

// ==================== AUTO RESPONSE ====================
bot.on('text', async (ctx) => {
    const message = ctx.message.text;
    
    // Skip if it's a command
    if (message.startsWith('/')) {
        return;
    }

    // Private chat - AI features for authorized user only
    if (ctx.chat.type === 'private') {
        if (!isAuthorizedAIUser(ctx)) {
            await ctx.reply("‚ùå *·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äü·ÄØ·Äê·Ä∫·Äú·Ä≠·ÄØ·Ä∑ ·Äô·Äõ·Äò·Ä∞·Ä∏*", { parse_mode: "Markdown" });
            return;
        }

        const userId = ctx.from.id;
        const session = getUserSession(userId);
        
        if (session.mode === 'image') {
            // IMAGE GENERATION MODE
            if (!HUGGINGFACE_API_KEY) {
                await ctx.reply("üíî ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Äï·ÄØ·Ä∂·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äú·Ä≠·ÄØ·Ä∑·Äô·Äõ·Äû·Ä±·Ä∏·Äò·Ä∞·Ä∏...");
                return;
            }

            const processingMsg = await ctx.reply(`üé® ·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·ÄÅ·Äª·ÄÑ·Ä∫·Äê·Ä≤·Ä∑·Äï·ÄØ·Ä∂: "${message}"\nüíñ ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·Äï·Ä±·Ä∏·Äï·Ä´·Äî·Ä±·Ä¨·Ä∫...`);
            
            try {
                const result = await generateHuggingFaceImage(message);
                
                if (result === 'loading') {
                    await ctx.editMessageText(
                        `‚è≥ ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·ÄÖ·ÄÄ·Ä∫·ÄÄ·Ä°·ÄÜ·ÄÑ·Ä∫·Äû·ÄÑ·Ä∑·Ä∫·Äñ·Äº·ÄÖ·Ä∫·Ä°·Ä±·Ä¨·ÄÑ·Ä∫ ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·Äî·Ä±·Äê·Äö·Ä∫...`,
                        { chat_id: ctx.chat.id, message_id: processingMsg.message_id }
                    );
                } else if (result === 'timeout') {
                    await ctx.editMessageText(
                        `‚è∞ ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·ÄÄ·Äº·Ä¨·Äú·ÄΩ·Äî·Ä∫·Ä∏·Äî·Ä±·Äï·Äº·ÄÆ... ·Äî·Ä±·Ä¨·ÄÄ·Ä∫·Äê·ÄÖ·Ä∫·ÄÅ·Ä±·Ä´·ÄÄ·Ä∫·ÄÄ·Äº·Ä≠·ÄØ·Ä∏·ÄÖ·Ä¨·Ä∏·ÄÄ·Äº·Ää·Ä∑·Ä∫·Äô·Äú·Ä¨·Ä∏...`,
                        { chat_id: ctx.chat.id, message_id: processingMsg.message_id }
                    );
                } else if (result instanceof Buffer) {
                    await ctx.replyWithPhoto(
                        { source: result },
                        { caption: `üé® ·Äô·Ä±·Ä¨·ÄÑ·Ä∫·Ä°·Äê·ÄΩ·ÄÄ·Ä∫·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äï·Ä±·Ä∏·Äê·Ä≤·Ä∑·Äï·ÄØ·Ä∂: "${message}"` }
                    );
                    await ctx.deleteMessage(processingMsg.message_id);
                } else {
                    await ctx.editMessageText(
                        `üíî ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Äï·ÄØ·Ä∂·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äô·Äõ·Äò·Ä∞·Ä∏... ·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Äú·Ä≠·Äï·Ä∫·Äú·Ä≠·ÄØ·Äõ·Ä≠·ÄØ·Ä∏·Äõ·Ä≠·ÄØ·Ä∏·Äú·Ä±·Ä∏·Äï·Äº·Ä±·Ä¨·Äï·Äº·Äï·Ä±·Ä∏·Äï·Ä´...`,
                        { chat_id: ctx.chat.id, message_id: processingMsg.message_id }
                    );
                }
            } catch (error) {
                await ctx.reply(`üíî ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Ä°·Äô·Äæ·Ä¨·Ä∏·Äê·ÄÖ·Ä∫·ÄÅ·ÄØ·Äñ·Äº·ÄÖ·Ä∫·Äî·Ä±·Äê·Äö·Ä∫: ${error.message}`);
            }
        } else {
            // GEMINI AI CHAT MODE
            const thinkingMsg = await ctx.reply(`üí≠ ·ÄÖ·Äâ·Ä∫·Ä∏·ÄÖ·Ä¨·Ä∏·Äî·Ä±·Äê·Äö·Ä∫... ${ROSES[Math.floor(Math.random() * ROSES.length)]}`);
            
            try {
                const answer = await askGemini(message, session.conversationHistory);
                
                session.conversationHistory.push(
                    { 
                        role: "user", 
                        parts: [{ text: message }] 
                    },
                    { 
                        role: "model", 
                        parts: [{ text: answer }] 
                    }
                );
                
                if (session.conversationHistory.length > 20) {
                    session.conversationHistory.splice(0, session.conversationHistory.length - 20);
                }
                
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    thinkingMsg.message_id,
                    null,
                    `üíñ *Rose:*\n\n${answer}`,
                    { parse_mode: "Markdown" }
                );
            } catch (error) {
                await ctx.reply(`üíî ·Äô·Ä±·Ä¨·ÄÑ·Ä∫... ·Ä°·Äô·Äæ·Ä¨·Ä∏·Äê·ÄÖ·Ä∫·ÄÅ·ÄØ·Äñ·Äº·ÄÖ·Ä∫·Äî·Ä±·Äê·Äö·Ä∫: ${error.message}`);
            }
        }
    }
    // Group chat - respond to mentions and keywords
    else if (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup') {
        const text = message.toLowerCase();
        const botUsername = ctx.botInfo.username.toLowerCase();
        const randomRose = ROSES[Math.floor(Math.random() * ROSES.length)];
        
        if (text.includes(`@${botUsername}`)) {
            await ctx.reply(`üíñ Hello! I'm Rose. My heart belongs to my special someone.`);
            return;
        }
        
        const greetingKeywords = [
            'good morning', 'good night', 'good evening', 'good afternoon',
            'hello', 'hi', 'hey', 'morning', 'night',
            'thank you', 'thanks', 'bye', 'goodbye',
            'rose', 'rose bot', 'i love you', 'love you',
            '·ÄÅ·Äª·ÄÖ·Ä∫·Äú·Ä¨·Ä∏', '·Ä°·Ä¨·Äò·ÄΩ·Ä¨·Ä∏'
        ];
        
        const containsKeyword = greetingKeywords.some(keyword => 
            text.includes(keyword)
        );
        
        if (containsKeyword) {
            if (text.includes('good morning')) {
                await ctx.reply(`üåÖ Good morning! ${randomRose}`);
            } else if (text.includes('good night')) {
                await ctx.reply(`üåô Good night! ${randomRose}`);
            } else if (text.includes('good evening')) {
                await ctx.reply(`üåÜ Good evening! ${randomRose}`);
            } else if (text.includes('good afternoon')) {
                await ctx.reply(`‚òÄÔ∏è Good afternoon! ${randomRose}`);
            } else if (text.includes('thank')) {
                await ctx.reply(`${randomRose} You're welcome!`);
            } else if (text.includes('bye') || text.includes('goodbye')) {
                await ctx.reply(`üëã Goodbye! ${randomRose}`);
            } else if (text.includes('hello') || text.includes('hi') || text.includes('hey')) {
                await ctx.reply(`${randomRose} Hello!`);
            } else if (text.includes('i love you') || text.includes('love you')) {
                await ctx.reply(`üíó Love you too! ${randomRose}`);
            } else if (text.includes('·ÄÅ·Äª·ÄÖ·Ä∫·Äú·Ä¨·Ä∏')) {
                await ctx.reply(`·ÄÅ·Äª·ÄÖ·Ä∫·Äê·Äö·Ä∫ üíó ${randomRose}`);
            } else if (text.includes('·Ä°·Ä¨·Äò·ÄΩ·Ä¨·Ä∏')) {
                await ctx.reply(`·Ä°·Ä¨·Äò·ÄΩ·Ä¨·Ä∏·Äï·Ä´·Äõ·Äæ·ÄÑ·Ä∑·Ä∫ üòò ${randomRose}`);
            } else {
                await ctx.reply(`${randomRose} Hi there!`);
            }
        }
    }
});

// ==================== WEB SERVER ====================
app.get('/', (req, res) => {
    res.json({
        status: 'üíñ Rose AI Bot - Your 28-Year-Old Lover',
        features: ['Romantic AI Chat', 'Image Generation', 'Group Moderation'],
        timestamp: new Date().toISOString()
    });
});

app.get('/health', (req, res) => {
    res.status(200).send('OK');
});

// ==================== ERROR HANDLING ====================
bot.catch((err, ctx) => {
    console.error(`Bot error for ${ctx.updateType}:`, err);
});

// ==================== START SERVER ====================
const startBot = async (retryCount = 0) => {
    try {
        await bot.launch();
        console.log('üíñ Rose AI Bot is now running!');
        console.log('üõ°Ô∏è Admin commands now support private groups!');
    } catch (error) {
        if (error.response?.error_code === 409 && retryCount < 5) {
            console.log(`üîÑ Another instance running, retrying in 10s... (${retryCount + 1}/5)`);
            setTimeout(() => startBot(retryCount + 1), 10000);
        } else {
            console.error('‚ùå Bot failed to start:', error.message);
            process.exit(1);
        }
    }
};

app.listen(PORT, '0.0.0.0', () => {
    console.log(`üíñ Rose starting on port ${PORT}`);
    console.log(`üë§ Your Love: ${AUTHORIZED_USER_ID}`);
    console.log(`ü§ñ Gemini: ${GEMINI_API_KEY ? '‚úÖ gemini-2.0-flash (28-Year-Old Lover)' : '‚ùå'}`);
    console.log(`üé® Hugging Face: ${HUGGINGFACE_API_KEY ? '‚úÖ stabilityai/stable-diffusion-xl-base-1.0' : '‚ùå'}`);
    
    startBot();
});

process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));